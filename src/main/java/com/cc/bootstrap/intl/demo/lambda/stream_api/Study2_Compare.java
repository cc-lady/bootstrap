package com.cc.bootstrap.intl.demo.lambda.stream_api;

/**
 * @Description: 流与集合
 * @author: ChenChen
 * @date: 2023/1/28 10:40
 */
public class Study2_Compare {
//    粗略地说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，
//    它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。（你可
//    以往集合里加东西或者删东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素
//    都得先算出来才能成为集合的一部分。）
//
//    相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计
//    算的。 这对编程有很大的好处。在第6章中，我们将展示构建一个质数流（2, 3, 5, 7, 11, …）有
//    多简单，尽管质数有无穷多个。这个思想就是用户仅仅从流中提取需要的值，而这些值——在用
//    户看不见的地方——只会按需生成。这是一种生产者－消费者的关系。从另一个角度来说，流就
//    像是一个延迟创建的集合：只有在消费者要求的时候才会计算值（用管理学的话说这就是需求驱
//    动，甚至是实时制造)。
//
//    与此相反，集合则是急切创建的（供应商驱动：先把仓库装满，再开始卖，就像那些昙花一
//    现的圣诞新玩意儿一样）。以质数为例，要是想创建一个包含所有质数的集合，那这个程序算起
//    来就没完没了了，因为总有新的质数要算，然后把它加到集合里面。当然这个集合是永远也创建
//    不完的，消费者这辈子都见不着了。

    //1.只能遍历一次
//    请注意，和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。
//    你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集
//    合之类的可重复的源，如果是I/O通道就没戏了）。

    //2.外部迭代与内部迭代了——Streams库的内部迭代可以自动选择一种适合你硬件的数据表示和并行实现。
//    使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。 相反，
//    Streams库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出
//    一个函数说要干什么就可以了。

}
