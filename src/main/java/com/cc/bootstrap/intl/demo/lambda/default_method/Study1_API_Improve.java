package com.cc.bootstrap.intl.demo.lambda.default_method;

/**
 * @Description: 默认方法
 * @author: ChenChen
 * @date: 2023/2/7 9:19
 */
public class Study1_API_Improve {
    public static void main(String[] args) {
//        传统上，Java程序的接口是将相关方法按照约定组合到一起的方式。实现接口的类必须为接
//        口中定义的每个方法提供一个实现，或者从父类中继承它的实现。但是，一旦类库的设计者需要
//        更新接口，向其中加入新的方法，这种方式就会出现问题。现实情况是，现存的实体类往往不在
//        接口设计者的控制范围之内，这些实体类为了适配新的接口约定也需要进行修改。由于Java 8的
//        API在现存的接口上引入了非常多的新方法，这种变化带来的问题也愈加严重。
//
//        Java 8为了解决这一问题引入了一种新的机制。Java 8中的接口现在
//        支持在声明方法的同时提供实现，这听起来让人惊讶！通过两种方式可以完成这种操作。其一，
//        Java 8允许在接口内声明静态方法。其二，Java 8引入了一个新功能，叫默认方法，通过默认方法
//        你可以指定接口方法的默认实现。换句话说，接口能提供方法的具体实现。因此，实现接口的类
//        如果不显式地提供该方法的具体实现，就会自动继承默认的实现。这种机制可以使你平滑地进行
//        接口的优化和演进。实际上，到目前为止你已经使用了多个默认方法。两个例子就是你前面已经
//        见过的List接口中的sort，以及Collection接口中的stream。

//        默认方法的主要目标用户是类库的设计者。正如我们后面所解释的，默认方法的引入就是为了以兼容的方式解决像
//        Java API这样的类库的演进问题

//        这就是引入默认方法的目的：
//        它让类可以自动地继承接口的一个默认实现。

//        本章的结构如下。
//        首先，我们会跟你一起剖析一个API演化的用例，探讨由此引发的各种问题。
//        紧接着我们会解释什么是默认方法，以及它们在这个用例中如何解决相应的问题。
//        之后，我们会展示如何创建自己的默认方法，构造Java语言中的多继承。
//        最后，我们会讨论一个类在使用一个签名同时继承多个默认方法时，Java编译器是如何解决可能的二义性（模糊性）问题的。

        //1.不断演进的 API
//        这就是默认方法试图解决的问题。它让类库的设计者放心地改进应用程序接口，无需担忧对
//        遗留代码的影响，这是因为实现更新接口的类现在会自动继承一个默认的方法实现。

//        不同类型的兼容性：二进制、源代码和函数行为
//        变更对Java程序的影响大体可以分成三种类型的兼容性，分别是：二进制级的兼容、源代
//        码级的兼容，以及函数行为的兼容。①刚才我们看到，向接口添加新方法是二进制级的兼容，
//        但最终编译实现接口的类时却会发生编译错误。了解不同类型兼容性的特性是非常有益的，下
//        面我们会深入介绍这部分的内容。
//        二进制级的兼容性表示现有的二进制执行文件能无缝持续链接（包括验证、准备和解析）
//        和运行。比如，为接口添加一个方法就是二进制级的兼容，这种方式下，如果新添加的方法不
//        被调用，接口已经实现的方法可以继续运行，不会出现错误。
//        简单地说，源代码级的兼容性表示引入变化之后，现有的程序依然能成功编译通过。比如，
//        向接口添加新的方法就不是源码级的兼容，因为遗留代码并没有实现新引入的方法，所以它们
//        无法顺利通过编译。
//        最后，函数行为的兼容性表示变更发生之后，程序接受同样的输入能得到同样的结果。比
//        如，为接口添加新的方法就是函数行为兼容的，因为新添加的方法在程序中并未被调用（抑或
//        该接口在实现中被覆盖了）。

        //2.概述默认方法
//        现在，接口包含的方法签名在它的实现类中也可以不提供实现。那么，谁来具体实现这些方法呢？实际上，缺
//        失的方法实现会作为接口的一部分由实现类继承（所以命名为默认实现），而无需由实现类提供。
//        那么，我们该如何辨识哪些是默认方法呢？其实非常简单。默认方法由default修饰符修饰，
//        并像类中声明的其他方法一样包含方法体。比如，你可以像下面这样在集合库中定义一个名为
//        Sized的接口，在其中定义一个抽象方法size，以及一个默认方法isEmpty：
//        public interface Sized {
//            int size();
//            default boolean isEmpty() {
//                return size() == 0;
//            }
//        }
//        这样任何一个实现了Sized接口的类都会自动继承isEmpty的实现。因此，向提供了默认实
//        现的接口添加方法就不是源码兼容的。

//        由于接口现在可以提供带实现的方法，是否这意味着Java已经在某种程度上实现了多继承？
//        如果实现类也实现了同样的方法，这时会发生什么情况？默认方法会被覆盖吗？现在暂时无需担
//        心这些，Java 8中已经定义了一些规则和机制来处理这些问题。(后续讲)

//        （记住，函数式接口只包含一个抽象方法，默认方法是种非抽象方法）。

//        Java 8中的抽象类和抽象接口
//        那么抽象类和抽象接口之间的区别是什么呢？它们不都能包含抽象方法和包含方法体的
//        实现吗？
//        首先，一个类只能继承一个抽象类，但是一个类可以实现多个接口。
//        其次，一个抽象类可以通过实例变量（字段）保存一个通用状态，而接口是不能有实例变
//        量的。

        //3.默认方法的使用模式
//        现在你已经了解了默认方法怎样以兼容的方式演进库函数了。除了这种用例，还有其他场景
//        也能利用这个新特性吗？当然有，你可以创建自己的接口，并为其提供默认方法。这一节中，我
//        们会介绍使用默认方法的两种用例：可选方法和行为的多继承。
        //3.1 可选方法
//        你很可能也碰到过这种情况，类实现了接口，不过却刻意地将一些方法的实现留白。我们以
//        Iterator接口为例来说。Iterator接口定义了hasNext、next，还定义了remove方法。Java 8
//        之前，由于用户通常不会使用该方法，remove方法常被忽略。因此，实现Interator接口的类
//        通常会为remove方法放置一个空的实现，这些都是些毫无用处的模板代码。
//        采用默认方法之后，你可以为这种类型的方法提供一个默认的实现，这样实体类就无需在自
//        己的实现中显式地提供一个空方法。比如，在Java 8中，Iterator接口就为remove方法提供了
//        一个默认实现，如下所示：
//        interface Iterator<T> {
//            boolean hasNext();
//            T next();
//            default void remove() {
//                throw new UnsupportedOperationException();
//            }
//        }
//        通过这种方式，你可以减少无效的模板代码。实现Iterator接口的每一个类都不需要再声
//        明一个空的remove方法了，因为它现在已经有一个默认的实现。
        //3.2 行为的多继承
//        默认方法让之前无法想象的事儿以一种优雅的方式得以实现，即行为的多继承。
//        Java的类只能继承单一的类，但是一个类可以实现多接口。要确认也很简单，下面是Java API
//        中对ArrayList类的定义：
//        public class ArrayList<E> extends AbstractList<E>
//                implements List<E>, RandomAccess, Cloneable,
//                Serializable, Iterable<E>, Collection<E> {
//        }
        //(1)类型的多继承
//        ArrayList继承了一个类，实现了六个接口。因此ArrayList实际是七个类型
//        的直接子类，分别是：AbstractList、List、RandomAccess、Cloneable、Serializable、
//        Iterable和Collection。所以，在某种程度上，我们早就有了类型的多继承。
        //(2)利用正交方法的精简接口
//        假设你需要为你正在创建的游戏定义多个具有不同特质的形状。有的形状需要调整大小，但
//        是不需要有旋转的功能；有的需要能旋转和移动，但是不需要调整大小。这种情况下，你怎么设
//        计才能尽可能地重用代码？
//        你可以定义一个单独的Rotatable接口，并提供两个抽象方法setRotationAngle和
//        getRotationAngle，如下所示：
//        public interface Rotatable {
//            void setRotationAngle(int angleInDegrees);
//            int getRotationAngle();
//            default void rotateBy(int angleInDegrees){
//                setRotationAngle((getRotationAngle () + angle) % 360);
//            }
//        }
//        这种方式和模板设计模式有些相似，都是以其他方法需要实现的方法定义好框架算法。
//        现在，实现了Rotatable的所有类都需要提供setRotationAngle和getRotationAngle
//        的实现，但与此同时它们也会天然地继承rotateBy的默认实现。
        //(3) 组合接口
//        通过组合这些接口，你现在可以为你的游戏创建不同的实体类。比如，Monster可以移动、
//        旋转和缩放。
//        public class Monster implements Rotatable, Moveable, Resizable {
//…
//        }
//        Monster类会自动继承Rotatable、Moveable和Resizable接口的默认方法。这个例子中，
//        Monster继承了rotateBy、moveHorizontally、moveVertically和setRelativeSize的
//        实现。
//        你现在可以直接调用不同的方法：
//        Monster m = new Monster();
//        m.rotateBy(180);
//        m.moveVertically(10);
//        假设你现在需要声明另一个类，它要能移动和旋转，但是不能缩放，比如说Sun。这时也无
//        需复制粘贴代码，你可以像下面这样复用Moveable和Rotatable接口的默认实现。图9-4是这一
//        场景的UML图表。
//        public class Sun implements Moveable, Rotatable {
//        }
//        像你的游戏代码那样使用默认实现来定义简单的接口还有另一个好处。假设你需要修改
//        moveVertically的实现，让它更高效地运行。你可以在Moveable接口内直接修改它的实现，
//        所有实现该接口的类会自动继承新的代码（这里我们假设用户并未定义自己的方法实现）。
    }
}
