package com.cc.bootstrap.intl.demo.lambda.stream_api;

/**
 * @Description: 并行数据处理与性能
 * Stream接口如何让你不用太费力气就能对数据集执行并行操作。它允
 * 许你声明性地将顺序流变为并行流。此外，你将看到Java是如何变戏法的，或者更实际地来说，
 * 流是如何在幕后应用Java 7引入的分支/合并框架的。你还会发现，了解并行流内部是如何工作的
 * 很重要，因为如果你忽视这一方面，就可能因误用而得到意外的（很可能是错的）结果。
 * 我们会特别演示，在并行处理数据块之前，并行流被划分为数据块的方式在某些情况下恰恰
 * 是这些错误且无法解释的结果的根源。因此，你将会学习如何通过实现和使用你自己的
 * Spliterator来控制这个划分过程。
 * @author: ChenChen
 * @date: 2023/1/30 15:41
 */
public class Study8_Parallel {
    public static void main(String[] args) {
        //1.并行流
//        了Stream接口可以让你非常方便地处理它的元素：可以通过对
//        收集源调用parallelStream方法来把集合转换为并行流。并行流就是一个把内容分成多个数据
//        块，并用不同的线程分别处理每个数据块的流。这样一来，你就可以自动把给定操作的工作负荷
//        分配给多核处理器的所有内核，让它们都忙起来。
//        假设你需要写一个方法，接受数字n作为参数，并返回从1到给定参数的所有数字的和。一个
//        直接（也许有点土）的方法是生成一个无穷大的数字流，把它限制到给定的数目，然后用对两个
//        数字求和的BinaryOperator来归约这个流，如下所示：
//        public static long sequentialSum(long n) {
//            return Stream.iterate(1L, i -> i + 1)
//                    .limit(n)
//                    .reduce(0L, Long::sum);
//        }
//        用更为传统的Java术语来说，这段代码与下面的迭代等价：
//        public static long iterativeSum(long n) {
//            long result = 0;
//            for (long i = 1L; i <= n; i++) {
//                result += i;
//            }
//            return result;
//        }
//        这似乎是利用并行处理的好机会，特别是n很大的时候。那怎么入手呢？你要对结果变量进
//        行同步吗？用多少个线程呢？谁负责生成数呢？谁来做加法呢？
//        根本用不着担心啦。用并行流的话，这问题就简单多了！
        //1.1 将顺序流转换为并行流 .parallel() ---------------------------------------------------
//        public static long parallelSum(long n) {
//            return Stream.iterate(1L, i -> i + 1)
//                    .limit(n)
//                    .parallel()
//                    .reduce(0L, Long::sum);
//        }
//        请注意，在现实中，对顺序流调用parallel方法并不意味着流本身有任何实际的变化。它
//        在内部实际上就是设了一个boolean标志，表示你想让调用parallel之后进行的所有操作都并
//        行执行。类似地，你只需要对并行流调用sequential方法就可以把它变成顺序流。请注意，你
//        可能以为把这两个方法结合起来，就可以更细化地控制在遍历流时哪些操作要并行执行，哪些要
//        顺序执行。例如，你可以这样做：
//        stream.parallel()
//                .filter(...)
// .sequential()  --------------------------------------------------- 把它变成顺序流
//                .map(...)
// .parallel()    --------------------------------------------------- 把它变成并行流
//                .reduce();
//        但最后一次parallel或sequential调用会影响整个流水线。在本例中，流水线会并行执 -----------------------！！
//        行，因为最后调用的是它。

        //配置并行流使用的线程池
//        看看流的parallel方法，你可能会想，并行流用的线程是从哪儿来的？有多少个？怎么
//        自定义这个过程呢？
//        并行流内部使用了默认的ForkJoinPool（7.2节会进一步讲到分支/合并框架），它默认的
//        线程数量就是你的处理器数量，这个值是由 Runtime.getRuntime().availableProcessors()得到的。
//        但是你可以通过系统属性 java.util.concurrent.ForkJoinPool.common.
//                parallelism来改变线程池大小，如下所示：
//        System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism","12");
//        这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个
//        并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值，
//        除非你有很好的理由，否则我们强烈建议你不要修改它。

        //使用正确的数据结构然后使其并行工作能够保证最佳的性能。

//        尽管如此，请记住，并行化并不是没有代价的。并行化过程本身需要对流做递归划分，把每
//        个子流的归纳操作分配到不同的线程，然后把这些操作的结果合并成一个值。但在多个内核之间
//        移动数据的代价也可能比你想的要大，所以很重要的一点是要保证在内核中并行执行工作的时间
//        比在内核之间传输数据的时间长。总而言之，很多情况下不可能或不方便并行化。然而，在使用
//        并行Stream加速代码之前，你必须确保用得对；如果结果错了，算得快就毫无意义了。

        //1.2 正确使用并行流
//        错用并行流而产生错误的首要原因，就是使用的算法改变了某些共享状态。
//        现在，记住要避免共享可变状态，确保并行Stream得到正
//        确的结果。接下来，我们会看到一些实用建议，你可以由此判断什么时候可以利用并行流来提升
//        性能。

        //1.3 高效使用并行流
        //(1)如果有疑问，测量。第一个也是最重要的建议就是用适当的基准来检查其性能。
        //(2)留意装箱。自动装箱和拆箱操作会大大降低性能。Java 8中有原始类型流（IntStream、
        //LongStream、DoubleStream）来避免这种操作，但凡有可能都应该用这些流。
        //(3)有些操作本身在并行流上的性能就比顺序流差。特别是limit和findFirst等依赖于元
        //素顺序的操作，它们在并行流上执行的代价非常大。例如，findAny会比findFirst性
        //能好，因为它不一定要按顺序来执行。你总是可以调用unordered方法来把有序流变成
        //无序流。那么，如果你需要流中的n个元素而不是专门要前n个的话，对无序并行流调用
        //limit可能会比单个有序流（比如数据源是一个List）更高效。
        //(4)还要考虑流的操作流水线的总计算成本。设N是要处理的元素的总数，Q是一个元素通过
        //流水线的大致处理成本，则N*Q就是这个对成本的一个粗略的定性估计。Q值较高就意味
        //着使用并行流时性能好的可能性比较大。
        //(5)对于较小的数据量，选择并行流几乎从来都不是一个好的决定。
        //(6)要考虑流背后的数据结构是否易于分解。例如，ArrayList的拆分效率比LinkedList
        //高得多，因为前者用不着遍历就可以平均拆分，而后者则必须遍历。另外，用range工厂
        //方法创建的原始类型流也可以快速分解。最后，你将在7.3节中学到，你可以自己实现
        //Spliterator来完全掌控分解过程。
        //(7)流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。
        //例如，一个SIZED流可以分成大小相等的两部分，这样每个部分都可以比较高效地并行处
        //理，但筛选操作可能丢弃的元素个数却无法预测，导致流本身的大小未知。
        //还要考虑终端操作中合并步骤的代价是大是小（例如Collector中的combiner方法）。
        //如果这一步代价很大，那么组合每个子流产生的部分结果所付出的代价就可能会超出通
        //过并行流得到的性能提升。

        //表7-1 流的数据源和可分解性
//        源                 可分解性
//        ArrayList         极佳
//        LinkedList        差
//        IntStream.range   极佳
//        Stream.iterate    差
//        HashSet           好
//        TreeSet           好

//        最后，我们还要强调并行流背后使用的基础架构是Java 7中引入的分支/合并框架。并行汇总
//        的示例证明了要想正确使用并行流，了解它的内部原理至关重要，所以我们会在下一节仔细研究
//        分支/合并框架。

        //2.分支/合并框架
//        分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任
//        务的结果合并起来生成整体结果。它是ExecutorService接口的一个实现，它把子任务分配给
//        线程池（称为ForkJoinPool）中的工作线程。首先来看看如何定义任务和子任务。

    }
}
